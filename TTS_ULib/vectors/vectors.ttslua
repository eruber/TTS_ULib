--- A collection of functions that operate on vectors.
-- A vector is a quantity fully described by both a magnitude and a direction;
-- while a scalar is a quantity that is fully described by only a magnitude.
--
-- In Tabletop Simulator (TTS) a vector is a table with duplicate keys x,y,z and 1,2,3.
--
-- A TTS vector typically represents a position, a rotation, or a direction.
--
-- If a TTS vector has a mismatch between its x,y,z and 1,2,3 keys then
-- the x,y,z keys will take precedence if they exist in the table.
--
-- Note that this package does its calculations using the 1,2,3 keys; if a
-- vector is provided with only x,y,z keys they will be duplicated to 1,2,3
-- keys prior to any calculations.
--
-- All vectors returned by this package will have **both** sets of duplicate keys -- the **xyz** set and the **123** set.
--
-- So in TTS, a valid vector must meet the following criteria:
--
--      1. It must be a table
--
--      2. It must have keys and/or indexes in one of three configurations:
--
--          (A) table keys of 'x', 'y', 'z'
--          (B) implied or specified indexes of 1,2,3
--          (C) both (A) and (B)
--
-- If a parameter, not meeting the above criteria, is passed to a function in this
-- package as a vector, an **assert** will be raised.
--
-- @module vectors
-- @curator eruber
-- @contributor eruber
-- @contributor tjakubo2
-- @contributor Banbury

-- Primarily from https://github.com/tjakubo2/TTS_lib/tree/master/vectors
-- with a few ideas from https://github.com/Banbury/tts_stdlib/tree/master/vectors
if type(package.loaded['vectors']) ~= 'table' then
    package.loaded['vectors'] = nil
end

if not package.loaded['vectors'] then
    vectors = {}
    package.loaded['vectors'] = vectors

    vectors._VERSION = '1.0.0'

    -- Private functions
    vectors._check_xyz_keys = function(v)
        local keys = { x = false, y = false, z = false }
        local r
        local c = 0
        if v.x ~= nil then
            keys.x = true
            c = c + 1
        end
        if v.y ~= nil then
            keys.y = true
            c = c + 1
        end
        if v.z ~= nil then
            keys.z = true
            c = c + 1
        end
        r = keys.x and keys.y and keys.z
        return r, c, keys
    end

    vectors._check_123_keys = function(v)
        local keys = { false, false, false }
        local r
        local c = 0
        if v[1] ~= nil then
            keys[1] = true
            c = c + 1
        end
        if v[2] ~= nil then
            keys[2] = true
            c = c + 1
        end
        if v[3] ~= nil then
            keys[3] = true
            c = c + 1
        end
        r = keys[1] and keys[2] and keys[3]
        return r, c, keys
    end

    vectors._emit_key_errors = function(c_123, keys_123, c_xyz, keys_xyz)
        local err = ""
        local zero_indexes = (c_123 == 0) and (c_xyz == 0)

        if ((c_123 < 3) and (c_123 > 0)) or zero_indexes then
            for k,val in pairs(keys_123) do
                if not val then
                    err = err .. string.format("Key: %s is missing!\n", k)
                end
            end
        end
        if ((c_xyz < 3) and (c_xyz > 0)) or zero_indexes then
            for k,val in pairs(keys_xyz) do
                if not val then
                    err = err .. string.format("Key: %s is missing!\n", k)
                end
            end
        end
        return err
    end

    vectors._dup_xyz_keys = function(v)
        v[1] = v.x
        v[2] = v.y
        v[3] = v.z
        return v
    end

    vectors._dup_123_keys = function(v)
        v.x = v[1]
        v.y = v[2]
        v.z = v[3]
        return v
    end

    vectors._check_mismatch = function(v)
        -- assumes that both 123 and xyz keys already exist
        -- a mismatch favors xyz as per TTS spec
        if v.x ~= v[1] then
            v[1] = v.x
        end
        if v.y ~= v[2] then
            v[2] = v.x
        end
        if v.z ~= v[3] then
            v[3] = v.z
        end
        return v
    end

    vectors._check_keys = function(v)
        local r
        local r_123, c_123, keys_123 = vectors._check_123_keys(v)
        local r_xyz, c_xyz, keys_xyz = vectors._check_xyz_keys(v)
        if r_123 and (not r_xyz) then
            -- Not really needed since we are doing our calcs with keys123
            v = vectors._dup_123_keys(v)
        end
        if r_xyz and (not r_123) then
            v = vectors._dup_xyz_keys(v)
        end
        if r_123 and r_xyz then
            v = vectors._check_mismatch(v)
        end
        r = r_123 or r_xyz
        if r then
            return true, v
        else
            print(vectors._emit_key_errors(c_123, keys_123, c_xyz, keys_xyz))
            return false, v
        end
    end

    vectors._check_vector = function(v, func_name, arg_number)
        assert(type(v) == 'table', 'vectors.'..func_name..': arg #'..tostring(n)..' is not a table!')
        local r, v = vectors._check_keys(v)
        assert(r, 'vector table key error, see above.')
        return v
    end

    -- ----------------------------------------------------------------------
    -- Public functions from this point...

    --- Sum of two vectors (of any size)
    -- @tparam vector v1
    -- @tparam vector v2
    -- @treturn vector Returns a new vector which is the sum of v1 and v2
    vectors.add = function(v1, v2)
        v1 = vectors._check_vector(v1, 'add', 1)
        v2 = vectors._check_vector(v2, 'add', 2)
        -- assert(type(v1) == 'table', 'vectors.add: arg#1 not a table!')
        -- assert(type(v2) == 'table', 'vectors.add: arg#2 not a table!')
        -- v1_check = vectors._check_keys(v1)
        -- v2_check = vectors._check_keys(v2)
        -- assert(v1_check and v2_check)
        local out = {}
        local k = 1
        while v1[k] ~= nil and v2[k] ~= nil do
            out[k] = v1[k]+v2[k]
            k = k+1
        end
        return vectors._dup_123_keys(out)
    end

    --- Inverse of a vector
    -- @tparam vector v
    -- @treturn vector Returns the inverse of vector v
    vectors.inverse = function(v)
        assert(type(v) == 'table', 'vectors.inverse: arg#1 not a table!')
        local out = {}
        local k = 1
        while v[k] ~= nil do
            out[k] = 1/v[k]
            k = k+1
        end
        return out
    end

    --- Multiply each element of a vector by a scalar factor
    -- @tparam vector v
    -- @tparam scalar factor Factor is a number to scale the vector by
    -- @treturn vector Returns a vector scaled by factor
    vectors.scale = function(v, factor)
        assert(type(v) == 'table', 'vectors.scale: arg#1 not a table!')
        assert(type(factor) == 'number', 'vectors.scale: arg#2 not a number!')
        local out = {}
        local k = 1
        while v[k] ~= nil do
            out[k] = v[k]*factor
            k = k+1
        end
        return out
    end

    --- Multiply each element of a vector by an element from a factor vector.
    -- (element-wise vector multiplication)
    -- @tparam vector v
    -- @tparam vector factor_v
    -- @treturn vector Returns a vector scaled by vector factor_v
    vectors.scaleEach = function(v, factor_v)
        assert(type(v) == 'table', 'vectors.scaleEach: arg#1 not a table!')
        assert(type(factor_v) == 'table', 'vectors.scaleEach: arg#2 not a table!')
        local out = {}
        local k = 1
        while v[k] ~= nil and factor_v[k] ~= nil do
            out[k] = v[k]*factor_v[k]
            k = k+1
        end
        return out
    end

    --- Length of a vector in the x-z plane (ignoring height, y)
    -- @tparam vector v
    -- @treturn scalar Returns length of vector v in the x-z plane
    vectors.length2D = function(v)
        assert(type(v) == 'table', 'vectors.length2D: arg#1 not a table!')
        return math.sqrt(v[1]*v[1] + v[3]*v[3])
    end

    --- Length of vector in all three dimensions x,y,z
    -- @tparam vector v
    -- @treturn scalar Returns length of vector v using all three dimensions
    vectors.length = function(v)
        assert(type(v) == 'table', 'vectors.length: arg#1 not a table!')
        return math.sqrt(v[1]*v[1] + v[2]*v[2] + v[3]*v[3])
    end

    --- Rotation of a 3D vector over its y-axis by a scalar radian quantity
    -- @tparam vector v A vector to rotate
    -- @tparam radians r A rotation factor
    -- @treturn vector Returns a vector rotated on its y-axis by r radians
    vectors.rotateRadians = function(v, r)
        assert(type(v) == 'table', 'vectors.rotateRadians: arg#1 not a table!')
        assert(type(r) == 'number', 'vectors.rotateRadians: arg#2 not a number!')
        local newX = math.cos(r) * v[1] + math.sin(r) * v[3]
        local newZ = math.sin(r) * v[1] * -1 + math.cos(r) * v[3]
        local out = {newX, v[2], newZ}
        local k=4
        while v[k] ~= nil do
            table.insert(out, v[k])
            k = k+1
        end
        return out
    end

    --- Rotation of a 3D vector over its y-axis, by a scalar degrees quantity
    -- @tparam vector v A vector to rotate
    -- @tparam degrees d A rotation factor
    -- @treturn vector Returns a vector rotated on its y-axis by d degrees
   vectors.rotateDegrees = function(v, d)
        assert(type(v) == 'table', 'vectors.rotateDegrees: arg#1 not a table!')
        assert(type(d) == 'number', 'vectors.rotateDegrees: arg#2 not a number!')
        local r = math.rad(d)
        return vectors.rotateRadians(vector, r)
    end

    --- Distance in the x-z plane between two positions
    -- @tparam vector|object p1 A position vector or a TTS object from which a position can be queried
    -- @tparam vector|object p2 A position vector or a TTS object from which a position can be queried
    -- @treturn scalar The distance between positions p1 and p2 in the x-z plane
    vectors.distance2D = function(p1, p2)
        assert(type(p1) == 'table' or type(p1) == 'userdata', 'vectors.distance2D: arg#1 not a table/object!')
        assert(type(p2) == 'table' or type(p2) == 'userdata', 'vectors.distance2D: arg#2 not a table/object!')
        if type(p1) == 'userdata' then
            p1 = p1.getPosition()
        end
        if type(p2) == 'userdata' then
            p2 = p2.getPosition()
        end
        return vectors.length2D(vectors.between(p1, p2))
    end

    --- 3D distance between two positions
    -- @tparam vector|object p1 A position vector or a TTS object from which a position can be queried
    -- @tparam vector|object p2 A position vector or a TTS object from which a position can be queried
    -- @treturn scalar The 3D distance between positions p1 and p2
    vectors.distance = function(p1, p2)
        assert(type(p1) == 'table' or type(p1) == 'userdata', 'vectors.distance: arg#1 not a table/object!')
        assert(type(p2) == 'table' or type(p2) == 'userdata', 'vectors.distance: arg#2 not a table/object!')
        if type(p1) == 'userdata' then
            p1 = p1.getPosition()
        end
        if type(p2) == 'userdata' then
            p2 = p2.getPosition()
        end
        return vectors.length(vectors.between(p1, p2))
    end

    --- Translate a vector to a printable string
    -- @tparam vector v The vector to convert into a printable string
    -- @treturn string The string representation of the vector, v.
    vectors.toString = function(v)
        return (string.format("{ %.2f, %.2f, %.2f }", v.x, v.y, v.z))
    end

    --- Print a vector's string representation to the console.
    -- @tparam vector v The vector to print to the console
    vectors.print = function(v)
        print(vectors.toString(v))
    end

    --- Dot product
    -- @tparam vector v1
    -- @tparam vector v2
    -- @treturn scalar Returns the dot product of vectors v1 and v2
    vectors.dotProd = function(v1, v2)
        assert(type(v1) == 'table', 'vectors.dotProd: arg#1 not a table!')
        assert(type(v2) == 'table', 'vectors.dotProd: arg#2 not a table!')
        local sum = 0
        local k = 1
        while v1[k] ~= nil and v2[k] ~= nil do
            sum = sum + v1[k]*v2[k]
            k = k+1
        end
        return sum
    end

    --- Compares two vectors element by element.
    -- Fails if length is uneven,
    -- @tparam vector v1 A vector to compare with vector v2
    -- @tparam vector v2 A vector to compare with vector v1
    -- @treturn boolean Returns the vectors v1 and v2 are identical.
    vectors.compare = function(v1, v2)
        assert(type(v1) == 'table', 'vectors.compare: arg#1 not a table!')
        assert(type(v2) == 'table', 'vectors.compare: arg#2 not a table!')
        if #v1 ~= #v2 then
            return false
        end
        local k = 1
        while v1[k] ~= nil and v2[k] ~= nil do
            if v1[k] ~= v2[k] then
                return false
            end
            k = k+1
        end
        return true
    end

    --- Euclidean norm
    -- @tparam vector v
    -- @treturn scalar The Euclidean Norm of vector v
    vectors.euclideanNorm = function(v)
        assert(type(v) == 'table', 'vectors.euclideanNorm: arg#1 not a table!')
        local selfDot = vectors.dotProd(v, v)
        return math.sqrt(selfDot)
    end

    --- Normalize
    -- Returns a new vector with the same direction but with a length of one unit.
    -- @tparam vector v A vector to normalize
    -- @treturn vector A new normalized Vector
    vectors.normalize = function(v)
        assert(type(v) == 'table', 'vectors.normalize: arg#1 not a table!')
        local len = vectors.length(v)
        v[1] = v[1] / len
        v[2] = v[2] / len
        v[3] = v[3] / len
        return v
    end

    --- Determine if a vector is a zero vector
    -- @tparam vector v A vector to test if it is a zero vector
    -- @treturn boolean Returns true if vector v is a zero vector
    vectors.isZero = function(v)
        assert(type(v) == 'table', 'vectors.isZero: arg#1 not a table!')
        if vectors.euclideanNorm(v) == 0 then
            return true
        else
            return false
        end
    end

    --- Convert a vector to unit vector in the same direction
    -- Note, this function will return a zero vector for a zero vector input
    -- since division by zero is undefined.
    -- @tparam vector v A vector to convert into a unit vector
    -- @treturn vector The unit vector of vector v
    vectors.unit = function(v)
        assert(type(v) == 'table', 'vectors.unit: arg#1 not a table!')
        if vectors.isZero(v) then
            return v
        end
        return vectors.scale(v, 1/vectors.euclideanNorm(v))
    end

    --- Angle between vectors in radians
    -- @tparam vector v1 A vector
    -- @tparam vector v2 A vector, if not specified, use vector {1,0,0}
    -- @treturn radians Returns the angle in radians between vectors v1 and v2.
    vectors.angleRadians = function(v1, v2)
        assert(type(v1) == 'table', 'vectors.angleRadians: arg#1 not a table!')
        assert(type(v2) == 'table', 'vectors.angleRadians: arg#2 not a table!')
        if v2 == nil then
            v2 = {1}
            for k = 2, #v1, 1 do
                table.insert(v2, 0)
            end
        end
        return math.acos( vectors.dotProd(v1, v2) / (vectors.euclideanNorm(v1)*vectors.euclideanNorm(v2)) )
    end

    --- Angle between vectors in radians, in the x-z plane
    -- @tparam vector v1 A vector
    -- @tparam vector v2 A vector, if not specified, use vector {1,0,0}
    -- @treturn radians Returns the angle in radians in the x-z plane between vectors v1 and v2.
    vectors.angleRadians2D = function(v1, v2)
        assert(type(v1) == 'table', 'vectors.angleRadians2D: arg#1 not a table!')
        assert(type(v2) == 'table', 'vectors.angleRadians2D: arg#2 not a table!')
        if v2 == nil then
            v2 = {1}
            for k = 2, #v1, 1 do
                table.insert(v2, 0)
            end
        end
        return ( math.atan2(v2[3], v2[1]) - math.atan2(v1[3], v1[1]) )
    end

    --- Same as vectors.angleRadians but in degrees
    -- @tparam vector v1 A vector
    -- @tparam vector v2 A vector, if not specified, use vector {1,0,0}
    -- @treturn degrees Returns the angle in degrees between vectors v1 and v2.
    vectors.angleDegrees = function(v1, v2)
        assert(type(v1) == 'table', 'vectors.angleDegrees: arg#1 not a table!')
        assert(type(v2) == 'table', 'vectors.angleDegrees: arg#2 not a table!')
        return math.deg(vectors.Angle(v1, v2))
    end

    --- Angle between vectors in degrees, in the x-z plane
    -- @tparam vector v1 A vector
    -- @tparam vector v2 A vector, if not specified, use vector {1,0,0}
    -- @treturn degrees Returns the angle in degrees in the x-z plane between vectors v1 and v2.
    vectors.angleDegrees2D = function(v1, v2)
        assert(type(v1) == 'table', 'vectors.angleDegrees2D: arg#1 not a table!')
        assert(type(v2) == 'table', 'vectors.angleDegrees2D: arg#2 not a table!')
        return math.deg(vectors.Angle2D(v1, v2))
    end

    --- Compute the vector pointing from one position to another position
    -- @tparam vector fromVector A vector from which the computed vector starts
    -- @tparam vector toVector A vector from which the computed vector ends
    -- @treturn vector Returns a vector that points from the fromVector to the toVector.
    vectors.between = function(fromVector, toVector)
        assert(type(fromVector) == 'table', 'vectors.between: arg#1 not a table!')
        assert(type(toVector) == 'table', 'vectors.between: arg#2 not a table!')
        return vectors.add(toVector, vectors.scale(fromVector, -1))
    end


    --- Compute a vector pointing between two positions
    -- @tparam vector|object p1 A position vector or a TTS object from which a position can be queried
    -- @tparam vector|object p2 A position vector or a TTS object from which a position can be queried
    -- @treturn vector Returns a half-length vector pointing between p1 and p2
    vectors.middle = function(p1, p2)
        assert(type(p1) == 'table' or type(p1) == 'userdata', 'vectors.middle: arg#1 not a table/object!')
        assert(type(p2) == 'table' or type(p2) == 'userdata', 'vectors.middle: arg#2 not a table/object!')
        return vectors.add(p1, vectors.scale(vectors.between(p1, p2), 0.5))
    end

    --- Subtract two vectors
    -- @tparam vector v1 A vector
    -- @tparam vector v2 A vector
    -- @treturn vector Returns a vector that is the result of subtracting vector v2 from vector v1.
    vectors.sub = function(v1, v2)
        assert(type(v1) == 'table', 'vectors.sub: arg#1 not a table!')
        assert(type(v2) == 'table', 'vectors.sub: arg#2 not a table!')
        return vectors.add(v1, vectors.scale(v2, -1))
    end

    --- Reverse the direction of a vector
    -- @tparam vector v A vector
    -- @treturn vector Returns a vector pointing in the opposite direction of vector v.
    vectors.reverse = function(v)
        assert(type(v) == 'table', 'vectors.reverse: arg#1 not a table!')
        return vectors.scale(v, -1)
    end

    --- Scale a vector to have specified length
    -- Note that a negative length will also reverse the direction of the vector.
    -- @tparam vector v A vector that will have its length changed to len.
    -- @tparam number len The new length to give to vector v.
    -- @treturn vector Returns a vector that has its length set to len.
    vectors.setLength = function(v, len)
        assert(type(v) == 'table', 'vectors.setLength: arg#1 not a table!')
        assert(type(len) == 'number', 'vectors.setLength: arg#1 not a number!')
        return vectors.scale(v, len/vectors.length(v))
    end

end
