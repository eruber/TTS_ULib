--- A collection of functions that operate on vectors
-- @module vectors
-- @curator eruber
-- @contributor eruber
-- @contributor tjakubo2

-- Primarily from https://github.com/tjakubo2/TTS_lib/tree/master/vectors
-- with a few ideas from https://github.com/Banbury/tts_stdlib/tree/master/vectors
if not package.loaded['vectors'] then
    vectors = {}
    package.loaded['vectors'] = Vect

    --- Sum of two vectors (of any size)
    vectors.Sum = function(vector1, vector2)
        assert(type(vector1) == 'table', 'vectors.Sum: arg#1 not a table!')
        assert(type(vector2) == 'table', 'vectors.Sum: arg#2 not a table!')
        local out = {}
        local k = 1
        while vector1[k] ~= nil and vector2[k] ~= nil do
            out[k] = vector1[k]+vector2[k]
            k = k+1
        end
        return out
    end

    --- Inverse of a vector
    vectors.Inverse = function(vector)
        assert(type(vector) == 'table', 'vectors.Inverse: arg#1 not a table!')
        local out = {}
        local k = 1
        while vector[k] ~= nil do
            out[k] = 1/vector[k]
            k = k+1
        end
        return out
    end

    --- Multiply each element of a vector by a factor
    vectors.Scale = function(vector, factor)
        assert(type(vector) == 'table', 'vectors.Scale: arg#1 not a table!')
        assert(type(factor) == 'number', 'vectors.Scale: arg#2 not a number!')
        local out = {}
        local k = 1
        while vector[k] ~= nil do
            out[k] = vector[k]*factor
            k = k+1
        end
        return out
    end

    --- Multiply each element of a vector by an element from factor vector
    -- (element-wise vector multiplication)
    vectors.ScaleEach = function(vector, factorVec)
        assert(type(vector) == 'table', 'vectors.ScaleEach: arg#1 not a table!')
        assert(type(factorVec) == 'table', 'vectors.ScaleEach: arg#2 not a table!')
        local out = {}
        local k = 1
        while vector[k] ~= nil and factorVec[k] ~= nil do
            out[k] = vector[k]*factorVec[k]
            k = k+1
        end
        return out
    end


    --- Length of  vector on X-Z plane (ignoring height)
    vectors.Length = function(vector)
        assert(type(vector) == 'table', 'vectors.Length: arg#1 not a table!')
        return math.sqrt(vector[1]*vector[1] + vector[3]*vector[3])
    end

    --- Rotation of a 3D vector over its second element axis, arg in radians
    -- Elements past 3rd are copied
    vectors.RotateRad = function(vector, radRotation)
        assert(type(vector) == 'table', 'vectors.RotateRad: arg#1 not a table!')
        assert(type(radRotation) == 'number', 'vectors.RotateRad: arg#2 not a number!')
        local newX = math.cos(radRotation) * vector[1] + math.sin(radRotation) * vector[3]
        local newZ = math.sin(radRotation) * vector[1] * -1 + math.cos(radRotation) * vector[3]
        local out = {newX, vector[2], newZ}
        local k=4
        while vector[k] ~= nil do
            table.insert(out, vector[k])
            k = k+1
        end
        return out
    end

    --- Distance between two points
    -- Points as vectors or objects (their positions)
    vectors.Distance = function(pos1, pos2)
        assert(type(pos1) == 'table' or type(pos1) == 'userdata', 'vectors.Distance: arg#1 not a table/object!')
        assert(type(pos2) == 'table' or type(pos2) == 'userdata', 'vectors.Distance: arg#2 not a table/object!')
        if type(pos1) == 'userdata' then
            pos1 = pos1.getPosition()
        end
        if type(pos2) == 'userdata' then
            pos2 = pos2.getPosition()
        end
        return vectors.Length(vectors.Between(pos1, pos2))
    end

    --- Print vector elements
    vectors.Print = function(vec, name)
        assert(type(vec) == 'table', 'vectors.Print: arg#1 not a table!')
        local out = '['
        if name then
            out = name .. ' => ' .. out
        end
        local k = 1
        while vec[k] ~= nil do
            out = out .. math.round(vec[k], 3) .. ' : '
            k = k+1
        end
        out = out:sub(1,-3) .. ']'
        print(out)
    end
    --- Round to decPlaces decimal places
    -- if decPlaces nil round to nearest integer
    math.round = function(arg, decPlaces)
        if decPlaces == nil then decPlaces = 0 end
        if decPlaces == 0 then
            frac = arg - math.floor(arg)
            if frac >= 0.5 then
                return math.ceil(arg)
            else
                return math.floor(arg)
            end
        else
            local mult = 10^(decPlaces or 0)
            return math.floor(arg * mult + 0.5) / mult
        end
    end

    --- Dot product
    vectors.DotProd = function(vector1, vector2)
        assert(type(vector1) == 'table', 'vectors.DotProd: arg#1 not a table!')
        assert(type(vector2) == 'table', 'vectors.DotProd: arg#2 not a table!')
        local sum = 0
        local k = 1
        while vector1[k] ~= nil and vector2[k] ~= nil do
            sum = sum + vector1[k]*vector2[k]
            k = k+1
        end
        return sum
    end

    --- Element-by-element comparison
    -- Fails if length uneven
    vectors.Compare = function(vector1, vector2)
        assert(type(vector1) == 'table', 'vectors.Compare: arg#1 not a table!')
        assert(type(vector2) == 'table', 'vectors.Compare: arg#2 not a table!')
        if #vector1 ~= #vector2 then
            return false
        end
        local k = 1
        while vector1[k] ~= nil and vector2[k] ~= nil do
            if vector1[k] ~= vector2[k] then
                return false
            end
            k = k+1
        end
        return true
    end

    --- Euclidean norm
    vectors.Norm = function(vec)
        local selfDot = vectors.DotProd(vec, vec)
        return math.sqrt(selfDot)
    end

    --- Convert a vector to unit vector in the same direction
    -- Return zero vector for zero vector
    vectors.ToUnit = function(vec)
        if vectors.Norm(vec) == 0 then
            return vec
        end
        return vectors.Scale(vec, 1/vectors.Norm(vec))
    end

    --- Angle between vectors in radians
    -- If second argument not provided, calculate typical angle (from [1, 0, 0, ...] )
    vectors.Angle = function(vector1, vector2)
        if vector2 == nil then
            vector2 = {1}
            for k = 2, #vector1, 1 do
                table.insert(vector2, 0)
            end
        end
        return math.acos( vectors.DotProd(vector1, vector2) / (vectors.Norm(vector1)*vectors.Norm(vector2)) )
    end

    --- Angle between vectors in radians, in plane
    -- If second argument not provided, calculate typical angle (from [1, 0, 0, ...] )
    vectors.Angle2D = function(vector1, vector2)
        if vector2 == nil then
            vector2 = {1}
            for k = 2, #vector1, 1 do
                table.insert(vector2, 0)
            end
        end
        return ( math.atan2(vector2[3], vector2[1]) - math.atan2(vector1[3], vector1[1]) )
    end

    --- Same as vectors.Angle but in degrees
    vectors.AngleDeg = function(vector1, vector2)
        return math.deg(vectors.Angle(vector1, vector2))
    end

    --- Same as vectors.Angle2D but in degrees
    vectors.AngleDeg2D = function(vector1, vector2)
        return math.deg(vectors.Angle2D(vector1, vector2))
    end

    --- vectors pointing from one position to another
    vectors.Between = function(fromVec, toVec)
        return vectors.Sum(toVec, vectors.Scale(fromVec, -1))
    end

    --- vectors pointing between two points
    vectors.Middle = function(p1, p2)
        return vectors.Sum(p1, vectors.Scale(vectors.Between(p1, p2), 0.5))
    end

    --- Subtract vector from another
    vectors.Sub = function(vector1, vector2)
        return vectors.Sum(vector1, vectors.Scale(vector2, -1))
    end

    --- Opposite of a vector
    vectors.Opposite = function(vector)
        return vectors.Scale(vector, -1)
    end

    --- Rotation of a 3D vector over its second element axis, arg in degrees
    -- Elements past 3rd are copied
    vectors.RotateDeg = function(vector, degRotation)
        local radRotation = math.rad(degRotation)
        return vectors.RotateRad(vector, radRotation)
    end

    --- Scale the vector to have set length
    -- Negative "length" - opposite of set length
    vectors.SetLength = function(vector, len)
        return vectors.Scale(vector, len/vectors.Length(vector))
    end
end
